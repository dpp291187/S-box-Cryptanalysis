SBOX4 = [
  0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71, 0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,
  0x00, 0x10, 0x43, 0x52, 0x35, 0x24, 0x77, 0x66, 0xC9, 0xD8, 0x8B, 0x9A, 0xFD, 0xEC, 0xBF, 0xAE,
  0x03, 0x23, 0x85, 0xA7, 0x69, 0x4B, 0xED, 0xCF, 0xB2, 0x90, 0x36, 0x14, 0xDA, 0xF8, 0x5E, 0x7C,
  0x02, 0x32, 0xC7, 0xF4, 0x5D, 0x6E, 0x9B, 0xA8, 0x7A, 0x49, 0xBC, 0x8F, 0x26, 0x15, 0xE0, 0xD3,
  0x05, 0x45, 0x39, 0x7D, 0xC2, 0x86, 0xFA, 0xBE, 0x57, 0x13, 0x6F, 0x2B, 0x94, 0xD0, 0xAC, 0xE8,
  0x04, 0x54, 0x7B, 0x2E, 0xF6, 0xA3, 0x8C, 0xD9, 0x9F, 0xCA, 0xE5, 0xB0, 0x68, 0x3D, 0x12, 0x47,
  0x07, 0x67, 0xBD, 0xDB, 0xAA, 0xCC, 0x16, 0x70, 0xE4, 0x82, 0x58, 0x3E, 0x4F, 0x29, 0xF3, 0x95,
  0x06, 0x76, 0xFF, 0x88, 0x9E, 0xE9, 0x60, 0x17, 0x2C, 0x5B, 0xD2, 0xA5, 0xB3, 0xC4, 0x4D, 0x3A,
  0x09, 0x89, 0x62, 0xEA, 0xB7, 0x3F, 0xD4, 0x5C, 0xAD, 0x25, 0xCE, 0x46, 0x1B, 0x93, 0x78, 0xF0,
  0x08, 0x98, 0x20, 0xB9, 0x83, 0x1A, 0xA2, 0x3B, 0x65, 0xFC, 0x44, 0xDD, 0xE7, 0x7E, 0xC6, 0x5F,
  0x0B, 0xAB, 0xE6, 0x4C, 0xDF, 0x75, 0x38, 0x92, 0x1E, 0xB4, 0xF9, 0x53, 0xC0, 0x6A, 0x27, 0x8D,
  0x0A, 0xBA, 0xA4, 0x1F, 0xEB, 0x50, 0x4E, 0xF5, 0xD6, 0x6D, 0x73, 0xC8, 0x3C, 0x87, 0x99, 0x22,
  0x0D, 0xCD, 0x5A, 0x96, 0x74, 0xB8, 0x2F, 0xE3, 0xFB, 0x37, 0xA0, 0x6C, 0x8E, 0x42, 0xD5, 0x19,
  0x0C, 0xDC, 0x18, 0xC5, 0x40, 0x9D, 0x59, 0x84, 0x33, 0xEE, 0x2A, 0xF7, 0x72, 0xAF, 0x6B, 0xB6,
  0x0F, 0xEF, 0xDE, 0x30, 0x1C, 0xF2, 0xC3, 0x2D, 0x48, 0xA6, 0x97, 0x79, 0x55, 0xBB, 0x8A, 0x64,
  0x0E, 0xFE, 0x9C, 0x63, 0x28, 0xD7, 0xB5, 0x4A, 0x80, 0x7F, 0x1D, 0xE2, 0xA9, 0x56, 0x34, 0xCB,
]

SBOX6 = [225,61,245,249,179,233,237,71,48,64,229,232,191,215,234,181,139,130,75,125,187,89,197,51,110,23,162,238,30,38,177,3,
     246,127,210,164,180,252,247,15,52,102,103,115,113,27,112,84,4,199,224,195,24,150,68,154,196,144,2,163,235,228,178,117,
     72,194,44,152,216,173,153,34,145,248,151,242,104,227,236,6,209,83,0,111,32,63,114,217,169,203,190,120,137,13,25,207,
     19,239,170,251,193,77,240,70,69,123,128,253,17,60,222,42,81,226,1,206,146,94,56,119,62,182,155,96,16,255,243,147,79,12,
     208,47,221,214,5,212,7,230,189,124,37,93,88,241,33,66,205,31,160,168,18,10,133,175,58,20,159,157,200,219,35,176,184,136,
     73,132,36,29,131,211,46,161,82,86,39,121,231,11,244,109,78,87,141,106,45,149,55,171,101,185,174,8,186,57,100,172,28,166,
     54,135,43,95,53,220,201,126,202,138,49,188,118,165,9,192,183,140,97,116,213,122,134,67,92,158,99,59,26,80,105,91,142,22,
     218,156,198,107,143,85,40,223,14,98,74,76,254,167,129,41,65,90,108,204,50,21,250,148]



SBOX7 =[0, 188, 251, 4, 58, 82, 164, 231, 117, 104, 76, 237, 41, 128, 78, 203, 1, 12, 6, 137, 191, 110, 48, 88, 129, 225, 163, 19, 31, 245, 73, 91, 224, 214, 126, 178, 34, 42, 89, 161, 255, 193, 32, 172, 238, 186, 147, 62, 64, 90, 235, 55, 21, 194, 201, 11, 121, 175, 95, 229, 92, 119, 60, 199, 240, 143, 192, 254, 211, 205, 57, 29, 116, 35, 252, 140, 25, 93, 239, 226, 127, 81, 45, 152, 96, 135, 66, 24, 18, 70, 124, 79, 198, 249, 227, 241, 160, 14, 134, 69, 246, 74, 166, 158, 77, 37, 33, 132, 253, 159, 23, 3, 118, 105, 167, 141, 123, 54, 180, 145, 236, 234, 113, 173, 242, 87, 151, 244, 120, 40, 72, 133, 195, 52, 179, 115, 59, 27, 83, 53, 181, 155, 208, 144, 109, 107, 217, 102, 184, 22, 183, 106, 146, 233, 185, 43, 153, 38, 5, 85, 223, 61, 7, 207, 51, 138, 17, 170, 65, 47, 247, 228, 68, 49, 71, 112, 28, 100, 220, 111, 216, 149, 215, 9, 243, 139, 202, 200, 8, 46, 171, 98, 80, 75, 84, 250, 36, 2, 15, 248, 136, 165, 162, 212, 86, 13, 20, 196, 122, 10, 154, 157, 67, 190, 125, 168, 209, 197, 103, 177, 206, 94, 156, 114, 187, 204, 148, 176, 230, 63, 218, 108, 219, 30, 26, 182, 189, 44, 210, 232, 213, 222, 169, 131, 99, 130, 174, 221, 50, 150, 39, 142, 16, 101, 97, 56]


SBOX8 =[246, 154, 190, 113, 4, 217, 219, 65, 247, 184, 133, 98, 228, 203, 128, 3, 42, 189, 174, 84, 165, 148, 142, 17, 31, 121, 67, 89, 233, 55, 150, 87, 25, 108, 12, 186, 213, 115, 57, 119, 166, 194, 224, 85, 255, 162, 86, 21, 218, 50, 64, 60, 24, 97, 245, 173, 36, 185, 70, 178, 9, 72, 88, 221, 96, 78, 234, 28, 236, 44, 240, 176, 193, 212, 160, 82, 69, 241, 135, 22, 61, 129, 58, 38, 220, 211, 2, 20, 172, 164, 18, 155, 104, 35, 232, 227, 106, 192, 15, 101, 161, 5, 80, 47, 6, 27, 122, 223, 110, 132, 230, 206, 196, 92, 146, 250, 170, 157, 169, 209, 29, 73, 137, 231, 251, 111, 216, 116, 7, 16, 188, 99, 235, 125, 14, 200, 33, 32, 19, 243, 149, 68, 253, 83, 94, 139, 252, 126, 158, 254, 62, 90, 100, 1, 156, 76, 30, 77, 95, 177, 145, 13, 107, 0, 8, 143, 205, 46, 49, 10, 163, 248, 202, 168, 40, 199, 141, 153, 198, 118, 215, 237, 180, 52, 187, 41, 34, 244, 130, 249, 127, 225, 207, 11, 242, 81, 195, 210, 140, 114, 167, 43, 238, 152, 91, 112, 48, 204, 197, 124, 74, 181, 59, 23, 123, 45, 109, 136, 103, 175, 26, 138, 208, 75, 117, 120, 214, 144, 66, 239, 53, 51, 182, 79, 171, 159, 93, 151, 226, 37, 102, 63, 183, 147, 54, 56, 71, 222, 39, 229, 105, 201, 179, 131, 134, 191]


SBOX9 = [
200,28,254,169,59,37,75,118,198,127,56,104,133,84,35,21,
160,93,49,113,57,228,185,253,141,13,176,249,99,43,50,207,
62,152,201,114,221,143,85,220,119,15,161,163,10,244,137,225,
55,96,73,25,255,11,5,194,138,124,208,162,134,250,86,136,
223,109,156,151,122,80,233,218,63,202,167,40,195,240,170,1,
42,214,0,217,53,146,112,100,111,159,30,182,216,245,2,248,
17,106,7,197,95,135,168,166,4,179,204,157,219,70,206,103,
237,68,67,132,91,142,83,242,101,54,107,82,123,183,89,209,
187,9,222,45,19,186,64,171,239,125,58,51,48,155,230,117,
241,164,196,131,191,79,36,116,81,149,234,97,144,129,165,47,
172,27,154,231,31,184,232,52,22,26,34,190,108,192,71,61,
128,6,105,243,126,76,227,251,41,210,205,235,94,3,177,236,
14,87,229,69,46,20,213,238,12,150,65,60,147,72,203,252,
121,189,173,102,140,92,247,38,174,193,226,77,175,158,178,212,
24,23,66,215,199,139,188,180,98,115,224,78,39,32,120,148,
211,44,74,18,110,16,8,246,181,88,33,153,90,29,130,145
]

SBOX10 =[
123,107,147,60,7,1,212,208,161,162,174,242,168,209,166,18,
254,84,127,246,125,152,183,21,114,158,38,115,113,67,199,217,
181,173,232,102,117,22,185,211,116,126,138,215,25,195,72,149,
247,227,133,153,49,79,119,150,118,89,143,225,193,187,42,109,
24,134,252,46,82,151,17,59,120,243,201,154,26,5,39,66,
248,73,245,179,99,218,41,101,74,111,207,69,2,155,8,103,
57,6,223,198,224,63,10,167,86,163,141,64,121,189,137,88,
249,110,106,238,237,204,222,228,206,4,27,192,51,175,156,188,
202,54,97,170,180,191,61,112,231,104,9,169,70,229,91,44,
250,142,55,135,194,176,139,182,203,190,160,50,177,235,15,81,
186,83,130,31,56,95,23,43,159,200,171,184,178,251,144,0,
3,45,157,197,205,92,128,129,47,53,11,196,34,210,145,16,
90,230,33,40,37,240,65,146,12,85,214,35,164,241,216,94,
233,100,255,28,236,71,14,30,122,68,20,244,226,219,234,98,
58,136,29,124,19,96,93,108,220,52,76,48,165,105,80,213,
77,13,32,221,75,131,78,239,87,62,253,36,132,140,148,172
]



SBOX17 =[
30, 43, 217, 136, 160, 233, 123, 179, 111, 93, 184, 114, 241, 4, 149, 107,
251, 21, 226, 131, 99, 25, 6, 48, 180, 186, 61, 7, 134, 191, 249, 109,
177, 23, 198, 105, 78, 183, 141, 89, 253, 68, 192, 90, 60, 49, 39, 240,
101, 225, 98, 63, 210, 77, 207, 120, 124, 129, 147, 162, 176, 11, 250, 59,
148, 37, 199, 9, 92, 34, 248, 53, 24, 62, 151, 238, 138, 82, 224, 26,
178, 44, 29, 206, 95, 132, 18, 128, 33, 185, 212, 236, 223, 169, 71, 170,
254, 219, 188, 156, 14, 182, 211, 31, 86, 166, 234, 244, 171, 116, 3, 252,
1, 193, 140, 13, 133, 126, 110, 35, 103, 139, 201, 173, 66, 167, 209, 158,
117, 70, 222, 119, 175, 174, 200, 81, 17, 146, 46, 232, 67, 87, 214, 230,
51, 181, 32, 115, 135, 55, 72, 157, 122, 45, 22, 10, 79, 15, 50, 187,
102, 83, 41, 216, 194, 229, 88, 12, 227, 57, 125, 19, 54, 190, 127, 94,
220, 197, 144, 242, 85, 208, 73, 189, 163, 16, 152, 243, 239, 96, 106, 36,
64, 245, 161, 47, 97, 150, 113, 213, 56, 130, 100, 27, 165, 215, 195, 143,
20, 58, 108, 52, 74, 218, 69, 2, 153, 145, 5, 38, 205, 203, 65, 235,
204, 247, 172, 80, 121, 28, 202, 246, 142, 228, 0, 91, 8, 104, 221, 155,
255, 75, 137, 40, 168, 118, 154, 196, 42, 76, 159, 84, 164, 231, 112, 237
]

SBOX20 =[
0xD7, 0x23, 0x02, 0x8A, 0x5B, 0x50, 0xF6, 0xBA, 0xB1, 0x1E, 0x2E, 0x80, 0xE8, 0x88, 0xB8, 0xF5,
0xF3, 0x15, 0x49, 0x7D, 0x19, 0x42, 0x4B, 0x76, 0x9A, 0xA4, 0x6E, 0x51, 0x2F, 0xF8, 0x30, 0x8F,
0xB7, 0xBE, 0x1C, 0xBC, 0x04, 0x58, 0x87, 0x61, 0x37, 0x96, 0x6B, 0x7B, 0xC8, 0x0F, 0x40, 0x81,
0x24, 0x28, 0xC1, 0xA0, 0xE6, 0x66, 0x00, 0xBB, 0xEB, 0x43, 0xB0, 0x69, 0x93, 0x8C, 0xA9, 0xB9,
0x06, 0xFE, 0x13, 0x05, 0xE7, 0x5F, 0xCF, 0x83, 0xE1, 0xB5, 0x52, 0x46, 0x65, 0x8D, 0x31, 0x82,
0x9F, 0xDE, 0x2B, 0x95, 0x5E, 0x79, 0x18, 0x22, 0xE4, 0xA6, 0xFA, 0x0C, 0x4C, 0x4D, 0xD6, 0x84,
0x75, 0x5C, 0xB2, 0x59, 0xF2, 0xEC, 0xD9, 0x35, 0xBD, 0x85, 0xC2, 0xA5, 0xC7, 0xED, 0x4E, 0x0A,
0x10, 0x73, 0x1F, 0xA7, 0xDD, 0x27, 0x55, 0x60, 0xFC, 0xDA, 0x08, 0x1A, 0xB6, 0x62, 0xD4, 0x97,
0x72, 0x74, 0x91, 0xD5, 0x20, 0x98, 0x57, 0xC0, 0x09, 0x41, 0x5A, 0xF0, 0x2C, 0x45, 0x94, 0xA2,
0xF7, 0x3B, 0xB4, 0xAB, 0x32, 0xCB, 0xEA, 0x16, 0x17, 0x1B, 0xAE, 0x2D, 0xAC, 0xFF, 0xF1, 0x7C,
0x8B, 0x0E, 0xCE, 0x6D, 0x48, 0x36, 0x3C, 0xDB, 0xC6, 0x56, 0x25, 0x9D, 0xB3, 0x89, 0xFD, 0x78,
0x33, 0xCC, 0xE5, 0xE0, 0x68, 0xF9, 0xFB, 0xD1, 0x4A, 0x3E, 0x3A, 0x11, 0x1D, 0xDC, 0x7A, 0x29,
0x63, 0xC4, 0xA3, 0xE2, 0xD3, 0x99, 0xDF, 0x0B, 0x2A, 0xBF, 0x07, 0x86, 0x44, 0x3F, 0x6F, 0x6A,
0x7E, 0xCA, 0x21, 0x92, 0xD0, 0x9E, 0xE9, 0x3D, 0xA1, 0xC3, 0x47, 0x34, 0xD8, 0x26, 0x6C, 0x5D,
0x8E, 0xAA, 0x70, 0x67, 0xF4, 0x4F, 0x9B, 0xD2, 0x01, 0x39, 0x77, 0x38, 0xEE, 0x0D, 0x53, 0xE3,
0x7F, 0xEF, 0x54, 0xAF, 0xA8, 0x64, 0x12, 0xAD, 0xCD, 0x9C, 0xC5, 0x71, 0x14, 0xC9, 0x90, 0x03

]

SBOX22 =[79, 39, 66, 188, 231, 175, 112, 3, 207, 61, 36, 113, 22, 60, 132, 208, 147, 172, 254, 195, 89, 249, 106, 203, 12, 152, 196, 108, 35, 105, 193, 80, 5, 83, 136, 128, 63, 129, 1, 40, 124, 176, 84, 186, 149, 67, 33, 174, 158, 49, 20, 24, 150, 251, 250, 252, 58, 180, 43, 81, 21, 45, 42, 189, 101, 85, 72, 68, 115, 255, 48, 247, 117, 47, 110, 11, 4, 90, 244, 216, 82, 160, 137, 235, 16, 165, 237, 10, 92, 123, 103, 241, 23, 87, 213, 227, 168, 120, 248, 109, 111, 161, 233, 217, 32, 131, 218, 224, 54, 156, 225, 26, 99, 243, 139, 146, 153, 98, 200, 214, 18, 104, 135, 253, 234, 151, 126, 41, 71, 62, 17, 228, 9, 212, 199, 53, 140, 143, 27, 242, 194, 240, 130, 107, 201, 230, 50, 118, 167, 6, 76, 125, 177, 91, 187, 178, 145, 73, 223, 70, 37, 184, 226, 30, 142, 238, 221, 65, 94, 215, 190, 19, 159, 0, 197, 121, 164, 173, 46, 134, 96, 93, 222, 162, 229, 182, 163, 210, 74, 245, 51, 198, 191, 56, 148, 59, 97, 29, 55, 69, 57, 86, 144, 138, 14, 127, 183, 15, 246, 157, 166, 202, 211, 154, 170, 205, 13, 78, 169, 114, 31, 171, 7, 236, 220, 119, 100, 34, 77, 204, 88, 141, 25, 181, 2, 219, 133, 44, 179, 95, 116, 122, 8, 38, 232, 28, 52, 75, 185, 239, 206, 192, 155, 64, 209, 102]



SBOX25 =[159, 115, 51, 207, 223, 31, 83, 3, 135, 12, 165, 128, 129, 25, 119, 212, 99, 134, 146, 183, 41, 180, 224, 253, 213, 70, 195, 229, 241, 137, 178, 248, 68, 205, 235, 106, 103, 238, 8, 156, 77, 199, 108, 9, 117, 153, 23, 42, 133, 202, 216, 217, 4, 55, 234, 89, 214, 69, 210, 148, 27, 64, 189, 74, 11, 122, 227, 163, 170, 174, 93, 177, 152, 53, 220, 60, 138, 33, 157, 191, 94, 182, 203, 209, 244, 76, 75, 26, 171, 39, 101, 35, 126, 30, 185, 81, 20, 173, 206, 143, 62, 18, 112, 233, 218, 250, 71, 167, 132, 197, 109, 92, 59, 144, 104, 72, 237, 127, 232, 154, 181, 246, 190, 142, 73, 15, 236, 179, 164, 193, 79, 149, 140, 172, 56, 211, 221, 230, 194, 98, 155, 239, 242, 58, 14, 44, 192, 131, 87, 204, 219, 48, 124, 130, 24, 91, 54, 136, 145, 5, 67, 121, 63, 225, 114, 222, 85, 247, 107, 2, 21, 7, 201, 162, 120, 147, 88, 50, 80, 100, 245, 125, 97, 111, 105, 96, 251, 57, 28, 123, 150, 160, 169, 102, 47, 45, 198, 196, 32, 176, 19, 86, 226, 188, 141, 158, 228, 215, 29, 84, 0, 90, 6, 184, 255, 61, 52, 43, 66, 78, 13, 243, 254, 240, 1, 166, 113, 118, 110, 161, 187, 10, 37, 40, 65, 175, 16, 38, 151, 231, 36, 17, 34, 82, 208, 249, 46, 49, 95, 252, 139, 116, 200, 22, 168, 186]


SBOX29 =[
0x99, 0x9A, 0xDE, 0x2D, 0x96, 0x8B, 0xCA, 0xA7, 0x4C, 0x2B, 0x80, 0x1D, 0xE5, 0xCF, 0x04, 0xF8,
   0x33, 0x7B, 0x7A, 0x73, 0x91, 0x4F, 0x15, 0xC3, 0x41, 0xBC, 0x23, 0xBA, 0x4D, 0x9E, 0x74, 0x68,
   0xBB, 0xA2, 0xE2, 0xCB, 0x2E, 0x10, 0xAE, 0x54, 0x77, 0xCE, 0x8D, 0x5E, 0x31, 0x09, 0x55, 0x46,
   0xA3, 0xF1, 0xD8, 0x2F, 0xB0, 0xDA, 0x22, 0x84, 0x39, 0x43, 0xF3, 0xB9, 0x63, 0x3E, 0xE8, 0x6D,
   0x02, 0x3A, 0x49, 0x6F, 0xE9, 0x07, 0x94, 0x7F, 0x16, 0x62, 0x78, 0xC8, 0x79, 0x17, 0x08, 0x36,
   0x57, 0xD3, 0xC7, 0x58, 0xDB, 0x75, 0xFD, 0xB4, 0xE3, 0x5C, 0x67, 0x87, 0x3C, 0x1A, 0x95, 0x7D,
   0xD1, 0x35, 0xB3, 0x7E, 0xEB, 0x65, 0xA0, 0x19, 0x3D, 0xE4, 0x13, 0x56, 0xD5, 0xA6, 0x0F, 0xAF,
   0xC1, 0xB2, 0xA5, 0xB6, 0x53, 0xBD, 0xB1, 0xD2, 0xDF, 0xF6, 0xAB, 0x14, 0xE0, 0x6A, 0x30, 0x70,
   0xA1, 0xFC, 0x28, 0x25, 0xA8, 0x9F, 0xAA, 0x9C, 0x1C, 0x92, 0x03, 0x6C, 0x47, 0x6B, 0x82, 0x52,
   0x5A, 0x93, 0xFA, 0x71, 0x5B, 0x0A, 0xB8, 0x0C, 0x64, 0x40, 0x18, 0xA9, 0x1F, 0x12, 0xFB, 0x83,
   0x34, 0xB7, 0x20, 0x1E, 0xAD, 0xC5, 0xF9, 0xC4, 0x85, 0x7C, 0x0B, 0x9D, 0x4B, 0x1B, 0xDC, 0x88,
   0x06, 0xD7, 0x45, 0x50, 0xE1, 0x37, 0xA4, 0x26, 0xEF, 0xC0, 0xC2, 0x44, 0xD6, 0x5D, 0x51, 0x11,
   0xBF, 0xFF, 0x66, 0xF0, 0x8C, 0x01, 0x8A, 0xD0, 0x76, 0x32, 0xC6, 0xE6, 0xF2, 0x5F, 0x59, 0x8F,
   0x72, 0x24, 0xE7, 0x90, 0x29, 0xBE, 0xD4, 0x0E, 0xCC, 0x21, 0xED, 0x98, 0x6E, 0x48, 0x8E, 0x97,
   0xEE, 0xC9, 0x61, 0xF7, 0x2A, 0x27, 0x81, 0x05, 0x89, 0xEA, 0xFE, 0x3F, 0x60, 0xEC, 0xDD, 0xCD,
   0x0D, 0x4E, 0x2C, 0xD9, 0xF4, 0x4A, 0x69, 0x00, 0xF5, 0xAC, 0x42, 0x9B, 0xB5, 0x3B, 0x38, 0x86
]


SBOX32 =[179, 6, 244, 24, 196, 215, 243, 241, 200, 72, 130, 3, 112, 250, 139, 33, 186, 69, 160, 182, 133, 93, 56, 181, 103, 245, 101, 48, 50, 110, 249, 173, 188, 109, 146, 126, 234, 128, 60, 217, 55, 166, 142, 240, 184, 113, 59, 218, 192, 201, 73, 26, 58, 157, 7, 39, 96, 148, 177, 40, 82, 87, 170, 88, 189, 150, 66, 210, 89, 18, 163, 42, 149, 219, 27, 116, 174, 51, 74, 238, 221, 125, 185, 92, 206, 121, 251, 119, 220, 91, 54, 252, 9, 4, 124, 204, 86, 76, 118, 32, 75, 61, 222, 108, 99, 129, 195, 36, 100, 65, 2, 90, 104, 71, 191, 111, 13, 37, 29, 147, 237, 105, 178, 127, 41, 46, 62, 31, 120, 47, 233, 25, 165, 227, 98, 22, 68, 144, 224, 123, 28, 45, 117, 143, 232, 44, 153, 203, 198, 194, 212, 175, 106, 161, 114, 43, 154, 183, 57, 229, 164, 134, 14, 162, 207, 97, 11, 49, 122, 239, 152, 80, 20, 135, 172, 228, 5, 131, 155, 30, 136, 247, 242, 53, 151, 156, 35, 226, 199, 225, 102, 158, 190, 0, 23, 85, 145, 246, 208, 176, 187, 8, 213, 15, 216, 214, 235, 141, 193, 168, 70, 132, 236, 34, 140, 94, 248, 197, 10, 209, 81, 205, 115, 79, 230, 16, 78, 21, 95, 83, 1, 255, 167, 67, 63, 137, 171, 107, 211, 12, 223, 202, 254, 19, 231, 138, 17, 169, 180, 84, 38, 77, 52, 159, 64, 253]



SBOX33 =[
212, 61, 245, 221, 87, 220, 252, 166, 17, 128, 244, 216, 127, 231, 218, 117, 78, 66, 142, 189, 95, 141, 228, 23, 186, 39, 82, 250, 43, 50, 85, 6, 243, 191, 195, 112, 113, 249, 247, 46, 49, 178, 182, 151, 149, 15, 145, 161, 32, 230, 208, 198, 9, 99, 160, 75, 224, 65, 2, 86, 222, 240, 83, 181, 136, 194, 56, 73, 201, 124, 77, 18, 69, 217, 103, 211, 152, 214, 248, 34, 197, 135, 0, 190, 16, 63, 147, 205, 92, 206, 123, 153, 76, 44, 13, 238, 7, 254, 90, 223, 196, 172, 209, 162, 164, 159, 64, 253, 5, 57, 235, 26, 133, 210, 4, 234, 67, 171, 25, 183, 59, 115, 79, 144, 1, 255, 215, 71, 174, 40, 193, 62, 237, 227, 36, 225, 38, 242, 125, 185, 52, 173, 137, 213, 20, 130, 236, 47, 80, 88, 3, 10, 100, 126, 27, 33, 111, 109, 200, 207, 22, 81, 89, 72, 140, 96, 48, 45, 70, 199, 58, 84, 131, 163, 54, 157, 246, 14, 241, 188, 170, 167, 108, 154, 60, 101, 55, 94, 180, 93, 122, 8, 91, 29, 176, 120, 41, 114, 51, 102, 30, 175, 53, 233, 204, 187, 202, 74, 21, 121, 179, 116, 12, 192, 119, 104, 148, 177, 229, 155, 98, 134, 169, 107, 150, 31, 11, 129, 156, 143, 106, 35, 203, 105, 158, 226, 110, 165, 24, 239, 42, 146, 138, 168, 251, 118, 68, 28, 132, 139, 184, 232, 19, 37, 219, 97]


SBOX36 =[51,81,142,30,60,100,174,140,96,218,85,171,39,98,154,87,
187,91,197,83,224,145,148,46,126,116,101,54,17,114,202,252,
214,57,149,158,115,58,79,61,192,179,242,186,37,175,71,21,
68,75,199,27,65,198,102,40,119,95,25,121,219,240,210,159,
34,129,155,137,141,176,73,168,207,72,167,216,50,74,52,193,
62,32,92,2,212,90,29,108,11,69,230,161,70,238,131,226,
229,157,234,112,248,177,1,185,41,93,191,172,183,211,208,80,
6,232,162,127,89,244,151,223,122,173,220,156,38,118,180,18,
24,138,169,147,239,15,196,14,28,4,217,84,245,249,103,77,
164,190,132,254,66,125,182,221,104,86,20,139,88,111,150,117,
195,0,19,203,16,120,213,166,188,250,53,241,97,165,205,200,
36,184,194,152,136,163,23,128,130,228,42,22,47,35,178,82,
67,135,55,235,7,255,12,253,63,146,107,181,33,143,246,206,
13,8,9,31,43,227,64,45,56,113,209,5,160,123,231,201,
237,99,124,236,3,94,76,170,153,247,48,59,233,133,49,144,
189,105,44,26,243,106,134,204,78,10,222,110,251,225,215,109]


SBOX56 =[
145,129,70,86,165,18,91,84,29,3,88,132,47,20,17,49,
217,158,107,219,147,10,39,130,60,179,202,34,190,185,128,63,
79,213,41,114,97,74,166,169,230,118,199,135,142,31,75,124,
73,93,6,83,151,99,120,203,19,122,64,248,106,4,183,250,
187,148,116,143,164,125,81,35,138,161,9,111,223,159,176,108,
157,2,50,45,155,178,113,7,14,181,194,174,244,239,54,0,
180,229,76,149,72,141,117,207,51,27,231,154,16,110,126,236,
28,242,197,121,25,104,172,240,37,221,13,24,94,103,198,205,
243,33,175,171,80,193,153,245,152,11,5,53,208,137,90,234,
38,42,177,67,85,26,101,201,215,186,127,78,150,216,96,218,
252,65,62,43,184,220,112,52,225,66,224,182,36,115,237,98,
77,191,57,123,95,8,167,55,227,56,131,30,222,200,136,235,
69,206,23,255,102,22,196,253,92,211,170,254,133,40,249,15,
160,251,68,214,192,109,87,48,189,195,188,228,12,139,105,163,
61,32,58,246,241,46,209,134,1,146,204,168,226,173,238,89,
21,144,119,82,233,156,140,162,44,59,232,212,100,247,210,71
]


SBOX69 =[
26,34,167,224,129,123,143,159,169,111,89,100,40,255,130,4,
93,65,175,9,229,53,252,58,230,101,220,180,223,139,225,178,
152,166,2,213,226,33,196,118,232,160,187,24,62,157,73,104,
239,105,247,155,217,0,39,45,140,8,3,42,122,154,179,214,
183,110,197,31,184,37,135,144,245,240,145,97,203,52,146,205,
234,13,158,76,211,188,51,59,69,115,134,199,96,64,117,151,
50,90,38,253,198,72,27,30,109,126,208,163,11,116,190,28,
63,25,210,191,75,215,248,207,162,171,142,228,92,12,87,85,
212,125,20,121,14,61,242,195,99,44,128,209,88,120,16,48,
6,98,219,241,156,74,35,168,23,141,18,186,174,114,68,107,
19,193,124,5,41,83,181,95,47,244,1,238,112,57,206,200,
79,81,173,250,237,227,54,137,236,176,194,106,164,103,70,138,
10,131,246,148,60,222,113,86,233,15,165,94,161,127,71,254,
78,204,251,136,119,177,231,80,29,201,55,218,17,102,132,108,
149,66,82,153,150,172,46,170,202,182,192,249,221,32,147,67,
36,49,21,243,84,133,235,91,43,185,7,189,56,22,77,216
]



import argparse
import math
import numpy as np
import re
from typing import List, Tuple, Dict

MDPISBOX =[
   0x01, 0x11, 0x91, 0xE1, 0xD1, 0xB1, 0x71, 0x61, 0xF1, 0x21, 0xC1, 0x51, 0xA1, 0x41, 0x31, 0x81,
   0x00, 0x10, 0x93, 0xE2, 0xD5, 0xB4, 0x77, 0x66, 0xF9, 0x28, 0xCB, 0x5A, 0xAD, 0x4C, 0x3F, 0x8E,
   0x08, 0x2C, 0x18, 0xF5, 0x90, 0x5D, 0xE9, 0xC4, 0xD3, 0x4E, 0xBA, 0xA7, 0x72, 0x8F, 0x6B, 0x36,
   0x0F, 0x3A, 0x84, 0x1F, 0x4B, 0xE0, 0x9E, 0xA5, 0x26, 0x6D, 0x73, 0xF8, 0xDC, 0xC7, 0x59, 0xB2,
   0x0C, 0x4F, 0x2E, 0xD0, 0x1C, 0xA2, 0xF3, 0xBD, 0x98, 0x86, 0x57, 0x79, 0xE5, 0x3B, 0xCA, 0x64,
   0x0A, 0x58, 0xB0, 0x39, 0xC3, 0x1A, 0x82, 0xDB, 0x65, 0xAC, 0x94, 0x2D, 0x47, 0x7E, 0xF6, 0xEF,
   0x06, 0x67, 0x3D, 0x2B, 0x8A, 0xFC, 0x16, 0x70, 0x44, 0xC2, 0xE8, 0xDE, 0x9F, 0xB9, 0xA3, 0x55,
   0x07, 0x76, 0xAF, 0xC8, 0x5E, 0x49, 0x60, 0x17, 0xBC, 0xEB, 0x22, 0x85, 0x33, 0xF4, 0x9D, 0xDA,
   0x0E, 0x8B, 0x46, 0x9C, 0x2F, 0x75, 0xD8, 0x52, 0x1E, 0x34, 0xA9, 0xE3, 0xF0, 0x6A, 0xB7, 0xCD,
   0x03, 0x95, 0xD9, 0x7D, 0xF2, 0xC6, 0xAA, 0x3E, 0xE7, 0x13, 0x6F, 0xBB, 0x54, 0x20, 0x8C, 0x48,
   0x0D, 0xAE, 0x5C, 0x63, 0xB8, 0x27, 0x35, 0x9A, 0xC0, 0x7F, 0x1D, 0x42, 0x89, 0xE6, 0xD4, 0xFB,
   0x04, 0xB3, 0xC5, 0x87, 0x69, 0x9B, 0x4D, 0xFF, 0x32, 0x50, 0xD6, 0x14, 0x2A, 0xA8, 0xEE, 0x7C,
   0x0B, 0xC9, 0x62, 0x4A, 0x37, 0xDF, 0x24, 0xEC, 0x8D, 0xB5, 0xFE, 0x96, 0x1B, 0x53, 0x78, 0xA0,
   0x05, 0xD2, 0xF7, 0xA4, 0xED, 0x6E, 0x5B, 0x88, 0x7A, 0x99, 0x3C, 0xCF, 0xB6, 0x15, 0x40, 0x23,
   0x02, 0xE4, 0x7B, 0xBE, 0xA6, 0x83, 0xCC, 0x29, 0x5F, 0xFA, 0x45, 0x30, 0x68, 0xDD, 0x12, 0x97,
   0x09, 0xFD, 0xEA, 0x56, 0x74, 0x38, 0xBF, 0x43, 0xAB, 0xD7, 0x80, 0x6C, 0xCE, 0x92, 0x25, 0x19]

MDPISBOX2 = [
    0x01, 0x11, 0x91, 0xE1, 0xD1, 0xB1, 0x71, 0x61, 0xF1, 0x21, 0xC1, 0x51, 0xA1, 0x41, 0x31, 0x81,
    0x00, 0x10, 0xE4, 0x95, 0xB3, 0xD2, 0x76, 0x67, 0x8B, 0x3A, 0xAE, 0x4F, 0xC9, 0x58, 0x2C, 0xFD,
    0x08, 0x2F, 0xF2, 0x1C, 0x5E, 0x90, 0xED, 0xC3, 0x37, 0x69, 0x74, 0x8A, 0xB8, 0xA6, 0x4B, 0xD5,
    0x0F, 0x38, 0x1A, 0x83, 0xE0, 0x49, 0x9B, 0xA2, 0xB4, 0x5D, 0xDF, 0xC6, 0x75, 0xFC, 0x6E, 0x27,
    0x0C, 0x4A, 0xD0, 0x2B, 0xA4, 0x1F, 0xF5, 0xBE, 0x63, 0xC8, 0xE2, 0x39, 0x56, 0x7D, 0x87, 0x9C,
    0x0A, 0x5C, 0x3D, 0xB0, 0x18, 0xC5, 0x84, 0xD9, 0xEA, 0xF7, 0x46, 0x7B, 0x93, 0x2E, 0xAF, 0x62,
    0x06, 0x66, 0x29, 0x3E, 0xFF, 0x88, 0x17, 0x70, 0x52, 0xA5, 0x9A, 0xBD, 0xEC, 0xDB, 0xC4, 0x43,
    0x07, 0x77, 0xCC, 0xAA, 0x4D, 0x5B, 0x60, 0x16, 0xD8, 0x9E, 0x35, 0xF3, 0x24, 0x82, 0xE9, 0xBF,
    0x0E, 0x89, 0x9F, 0x47, 0x72, 0x2A, 0xDC, 0x54, 0xCE, 0xB6, 0xF0, 0x68, 0xAD, 0xE5, 0x33, 0x1B,
    0x03, 0x92, 0x7E, 0xDD, 0xC7, 0xF4, 0xA8, 0x3B, 0x4C, 0x8F, 0x53, 0x20, 0x6A, 0xB9, 0x15, 0xE6,
    0x0D, 0xAB, 0x65, 0x5F, 0x26, 0xBC, 0x32, 0x98, 0xF9, 0xD3, 0x8D, 0xE7, 0x1E, 0x44, 0x7A, 0xC0,
    0x04, 0xB5, 0x86, 0xC2, 0x99, 0x6D, 0x4E, 0xFA, 0x7F, 0xEB, 0x28, 0xAC, 0xD7, 0x13, 0x50, 0x34,
    0x0B, 0xCD, 0x48, 0x64, 0xDA, 0x36, 0x23, 0xEF, 0xA0, 0x7C, 0x19, 0x55, 0xFB, 0x97, 0xB2, 0x8E,
    0x05, 0xD4, 0xA3, 0xF6, 0x6B, 0xEE, 0x59, 0x8C, 0x25, 0x40, 0xB7, 0x12, 0x3F, 0xCA, 0x9D, 0x78,
    0x02, 0xE3, 0xBB, 0x79, 0x85, 0xA7, 0xCF, 0x2D, 0x96, 0x14, 0x6C, 0xDE, 0x42, 0x30, 0xF8, 0x5A,
    0x09, 0xFE, 0x57, 0xE8, 0x3C, 0x73, 0xBA, 0x45, 0x1D, 0x22, 0xCB, 0x94, 0x80, 0x6F, 0xD6, 0xA9,
]

AES = [
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
]


def is_power_of_two(x: int) -> bool:
    """Return True iff x is a power of two (x=2^k, k>=0)."""
    return x > 0 and (x & (x - 1)) == 0


def bitstring_to_hex(bits: str) -> str:
    """Convert a bitstring (MSB-first) to '0x...' with zero padding to a full nibble."""
    if not bits:
        return "0x0"
    pad = (-len(bits)) % 4
    if pad:
        bits = '0' * pad + bits
    return f"0x{int(bits, 2):0{len(bits)//4}X}"


def format_sbox_hex(sbox: List[int]) -> str:
    """Pretty-print S-box as hex, 16 values per row."""
    lines = []
    for i in range(0, len(sbox), 16):
        line = ", ".join(f"0x{v:02X}" for v in sbox[i:i+16])
        lines.append("   " + line)
    return "\n".join(lines)


# =========================
# ===== CORE ROUTINES =====
# =========================
def invert_sbox(sbox: List[int]) -> List[int]:
    """Return inverse permutation of a bijective S-box (no bijective check here)."""
    inv = [0] * len(sbox)
    for i, v in enumerate(sbox):
        inv[v] = i
    return inv


def check_bijective(sbox: List[int], n: int) -> bool:
    """Check if S-box is a permutation on {0..2^n-1}."""
    return set(sbox) == set(range(1 << n))


def count_fixed_and_opposite_fixed_points(sbox: List[int], n: int) -> Tuple[int, int]:
    """Count fixed points S(x)=x and opposite fixed points S(x)=(~x mod 2^n)."""
    fp = ofp = 0
    mask = (1 << n) - 1
    for x in range(1 << n):
        y = sbox[x]
        if y == x:
            fp += 1
        elif y == (mask ^ x):
            ofp += 1
    return fp, ofp


def boolean_functions_from_sbox(sbox: List[int], n: int) -> List[str]:
    """
    Extract n coordinate Boolean functions f_i as bitstrings of length 2^n.
    Convention: bit i is LSB=0. The bitstring enumerates x = 0..2^n-1.
    """
    funcs = []
    for i in range(n):
        bits = ''.join(str((sbox[x] >> i) & 1) for x in range(1 << n))
        funcs.append(bits)
    return funcs


def bic_boolean_functions(funcs: List[str]) -> List[Tuple[Tuple[int, int], str]]:
    """
    Build XOR-combination (BIC) functions: g_{i,j} = f_i XOR f_j for i<j.
    Return list of ((i,j), bitstring).
    """
    out = []
    m = len(funcs)
    for i in range(m):
        for j in range(i + 1, m):
            xored = ''.join(str(int(funcs[i][k]) ^ int(funcs[j][k])) for k in range(len(funcs[i])))
            out.append(((i, j), xored))
    return out


def walsh_spectrum(bits: str, n: int) -> np.ndarray:
    """
    Compute Walsh spectrum W_f(w) for Boolean function 'bits' (length 2^n):
      W_f(w) = sum_x (-1)^{ f(x) XOR (x·w) }.
    Direct method (fine for n<=8). For larger n, use FWHT.
    """
    f_vals = np.fromiter((int(b) for b in bits), dtype=np.int8, count=1 << n)
    W = np.zeros(1 << n, dtype=np.int32)
    for w in range(1 << n):
        acc = 0
        for x in range(1 << n):
            dot = (x & w).bit_count() & 1
            acc += 1 if (f_vals[x] ^ dot) == 0 else -1
        W[w] = acc
    return W


def nonlinearity_from_walsh(W: np.ndarray, n: int) -> int:
    """
    Nonlinearity of Boolean function:
      NL(f) = 2^{n-1} - (max_w |W_f(w)|)/2
    Return integer.
    """
    return int((1 << (n - 1)) - (int(np.max(np.abs(W))) // 2))


def sac_matrix(bits: str, n: int) -> np.ndarray:
    """
    Strict Avalanche Criterion (SAC) matrix of shape (2^n) x n:
      SAC[x,i] = f(x) XOR f(x XOR e_i)
    """
    f_vals = np.fromiter((int(b) for b in bits), dtype=np.int8, count=1 << n)
    sac = np.zeros((1 << n, n), dtype=np.int8)
    for x in range(1 << n):
        fx = f_vals[x]
        for i in range(n):
            sac[x, i] = fx ^ f_vals[x ^ (1 << i)]
    return sac


def lat(S: List[int], n: int, m: int) -> List[List[int]]:
    """
    Linear Approximation Table
      L(alpha, beta) = e - 2^(n-1),
      where e = #{ x : alpha·x XOR beta·S(x) == 0 }.
    This is the 'bias' table (Walsh/2), not the raw Walsh sum.
    """
    def dot(u: int, v: int) -> int:
        # parity of bitwise dot product
        return (u & v).bit_count() & 1

    L = [[0] * (1 << m) for _ in range(1 << n)]
    for alpha in range(1 << n):
        for beta in range(1 << m):
            e = 0
            for x in range(1 << n):
                if dot(alpha, x) ^ dot(beta, S[x]) == 0:
                    e += 1
            L[alpha][beta] = e - (1 << (n - 1))   # <-- bias, matches your code
    return L


def ddtsbox(S: List[int], n: int, m: int) -> List[List[int]]:
    """
    Differential Distribution Table:
      D(alpha,beta) = # { x | S(x) XOR S(x XOR alpha) = beta }.
    """
    D = [[0] * (1 << m) for _ in range(1 << n)]
    for a in range(1 << n):
        for x in range(1 << n):
            b = S[x] ^ S[x ^ a]
            D[a][b] += 1
    return D


def lap_user_def(S: List[int], n: int, m: int) -> Tuple[float, List[List[int]], int]:
    """
    EXACT user's LAP:
      - Build LAT
      - Take all abs(L[a][b]), sort descending
      - Take the second-largest value
      - Divide by 2^n
    Returns (lap_ratio, LAT, second_largest_abs_value).
    """
    L = lat(S, n, m)
    all_values = [abs(L[a][b]) for a in range(1 << n) for b in range(1 << m)]
    all_values.sort(reverse=True)
    second_largest_abs_value = all_values[1] if len(all_values) >= 2 else all_values[0]
    lap_ratio = second_largest_abs_value / float(1 << n)
    return lap_ratio, L, second_largest_abs_value


def dap_user_def(S: List[int], n: int, m: int) -> Tuple[float, List[List[int],], int]:
    """
    EXACT user's DAP (named cal_ddt in your original code):
      - Build DDT
      - Take unique values, sort descending
      - Choose the first value that is NOT equal to 2^n
      - Divide by 2^n
    Returns (dap_ratio, DDT, chosen_value).
    """
    D = ddtsbox(S, n, m)
    vals = []
    for a in range(1 << n):
        for b in range(1 << m):
            vals.append(D[a][b])
    vals = sorted(set(vals), reverse=True)
    chosen = 0
    for v in vals:
        if v != (1 << n):
            chosen = v
            break
    dap_ratio = chosen / float(1 << n)
    return dap_ratio, D, chosen


def compute_bct_fbct_second_largest(S: List[int], n: int) -> Tuple[int, int]:
    """
    Compute BCT and FBCT and return their second-largest values (global).
    """
    inv = invert_sbox(S)

    bct = [[0] * (1 << n) for _ in range(1 << n)]
    for a in range(1 << n):
        for b in range(1 << n):
            c = 0
            for x in range(1 << n):
                if (inv[S[x] ^ b] ^ inv[S[x ^ a] ^ b]) == a:
                    c += 1
            bct[a][b] = c

    fbct = [[0] * (1 << n) for _ in range(1 << n)]
    for a in range(1 << n):
        for b in range(1 << n):
            c = 0
            for x in range(1 << n):
                if (S[x] ^ S[x ^ a] ^ S[x ^ b] ^ S[x ^ a ^ b]) == 0:
                    c += 1
            fbct[a][b] = c

    def second_largest(table: List[List[int]]) -> int:
        largest = second = -10**9
        for row in table:
            for v in row:
                if v > largest:
                    second = largest
                    largest = v
                elif largest > v > second:
                    second = v
        return second

    return second_largest(bct), second_largest(fbct)


def confusion_metrics(S: List[int], n: int) -> Tuple[float, float]:
    """
    Confusion-like metrics per your older code:
      E_k = (1/2^n) Σ_x ((HW(S(x)) - HW(S(x⊕k)))^2)/4
      MCC = 2nd smallest of {E_k}
      CCV = Var over E'_k = (1/2^n) Σ_x ((HW(S(x)) - HW(S(x⊕k)))^2)
    """
    def hw(x: int) -> int:
        return x.bit_count()

    E, E1 = [], []
    for k in range(1, 1 << n):
        s = s1 = 0.0
        for x in range(1 << n):
            d = hw(S[x]) - hw(S[x ^ k])
            s += (d * d) / 4.0
            s1 += (d * d)
        E.append(s / (1 << n))
        E1.append(s1 / (1 << n))
    E.sort()
    mcc = E[1] if len(E) >= 2 else (E[0] if E else 0.0)
    mu = sum(E1) / len(E1) if E1 else 0.0
    ccv = sum((v - mu) ** 2 for v in E1) / len(E1) if E1 else 0.0
    return mcc, ccv


def snr_metric(S: List[int], n: int) -> float:
    """
    SNR = n * 2^{2n} / sqrt( sum_w ( sum_i W_{f_i}(w) )^4 ).
    """
    funcs = boolean_functions_from_sbox(S, n)
    Wsum = np.zeros(1 << n, dtype=np.int64)
    for bits in funcs:
        Wsum += walsh_spectrum(bits, n)
    denom = int(np.sum((Wsum ** 4)))
    denom = max(denom, 1)
    return (n * (1 << (2 * n))) / (denom ** 0.5)


# =========================
# ===== ANF (MOEBIUS) =====
# =========================
def index_to_term_with_parentheses(index: int, variables: List[str]) -> str:
    """Convert monomial mask to AND-term, e.g., (x3 & x1). 0 -> '1'."""
    if index == 0:
        return "1"
    parts = [v for i, v in enumerate(variables) if (index >> i) & 1]
    return '(' + ' & '.join(parts) + ')'


def generate_all_anf_expressions(coefs: np.ndarray, variables: List[str]) -> Tuple[List[str], int, int]:
    """Build ANF strings and count AND/XOR gates."""
    exprs = []
    total_and = total_xor = 0
    for row in coefs:
        terms = [index_to_term_with_parentheses(i, variables) for i, c in enumerate(row) if c]
        expr = ' ^ '.join(terms) if terms else '0'
        exprs.append(expr)
        total_and += expr.count('&')
        total_xor += expr.count('^')
    return exprs, total_and, total_xor


def max_variables_in_terms(exprs: List[str]) -> int:
    """Algebraic degree = max number of distinct variables in any AND-term."""
    pat = re.compile(r'x\d+')
    best = 0
    for e in exprs:
        for term in e.split('^'):
            best = max(best, len(set(pat.findall(term))))
    return best


def anf_via_moebius(S: List[int], n: int) -> Tuple[List[str], int, int, int]:
    """
    Compute ANF of each coordinate with in-place Möbius transform over truth tables.
    Variables named x{n-1}..x0 (MSB..LSB for visual consistency).
    """
    T = np.zeros((n, 1 << n), dtype=np.int8)
    for x in range(1 << n):
        y = S[x]
        for row in range(n):                      # row 0 is MSB
            T[row, x] = (y >> (n - 1 - row)) & 1

    # Möbius transform per row
    C = T.copy()
    for r in range(n):
        for i in range(n):
            step = 1 << i
            for m in range(1 << n):
                if m & step:
                    C[r, m] ^= C[r, m ^ step]

    vars_names = [f'x{i}' for i in range(n - 1, -1, -1)]
    exprs, t_and, t_xor = generate_all_anf_expressions(C, vars_names)
    ad = max_variables_in_terms(exprs)
    return exprs, t_and, t_xor, ad


# =========================
# ===== MAIN METRICS ======
# =========================
def per_function_metrics(func_bits: str, n: int) -> Dict[str, object]:
    """
    Compute NL and SAC (vector & average) for a single Boolean function.
    """
    W = walsh_spectrum(func_bits, n)
    NL = nonlinearity_from_walsh(W, n)
    SAC = sac_matrix(func_bits, n)
    sac_per_bit = SAC.sum(axis=0) / float(1 << n)  # length n, each ideally ~0.5
    sac_avg = sac_per_bit.mean()
    return {"NL": int(NL), "SAC_vector": sac_per_bit.tolist(), "SAC_avg": float(sac_avg)}


def aggregate_metrics(S: List[int], n: int) -> Dict[str, object]:
    """Compute and return all requested metrics in a single structure."""
    # Basic checks
    bij = check_bijective(S, n)
    fp, ofp = count_fixed_and_opposite_fixed_points(S, n)

    # Coordinate & BIC Boolean functions
    coords = boolean_functions_from_sbox(S, n)
    bic = bic_boolean_functions(coords)  # list of ((i,j), bits)

    # Per-function NL & SAC (coords)
    per_coord = [per_function_metrics(bits, n) for bits in coords]
    NL_coords = [pc["NL"] for pc in per_coord]
    SAC_coords_avg = [pc["SAC_avg"] for pc in per_coord]

    # Per-function NL & SAC (BIC)
    per_bic = []
    for (i, j), bits in bic:
        m = per_function_metrics(bits, n)
        per_bic.append({"pair": (i, j), **m})
    NL_bic_vals = [pb["NL"] for pb in per_bic]
    SAC_bic_avg = [pb["SAC_avg"] for pb in per_bic]

    # LAP & DAP by user's definitions
    LAP_ratio, LAT, LAP_abs2 = lap_user_def(S, n, n)
    DAP_ratio, DDT, DAP_val = dap_user_def(S, n, n)

    # BCT/FBCT (second-largest)
    BCT2, FBCT2 = compute_bct_fbct_second_largest(S, n)

    # Overlap family
    TO = calculate_TO(S, n)
    MTO = calculate_MTO(S, n)
    RTO = calculate_RTO(S, n)

    # Confusion & SNR
    MCC, CCV = confusion_metrics(S, n)
    SNR = snr_metric(S, n)

    # ANF
    anf_exprs, total_and, total_xor, ad = anf_via_moebius(S, n)

    return {
        "Bijective": bij,
        "FP": fp, "OFP": ofp,
        "PerCoord": per_coord,                     # list of dicts: NL, SAC_vector, SAC_avg
        "PerBIC": per_bic,                         # list of dicts: pair,(i,j), NL, SAC_vector, SAC_avg
        "Sbox_NL_avg": float(np.mean(NL_coords)) if NL_coords else 0.0,
        "BIC_NL_avg": float(np.mean(NL_bic_vals)) if NL_bic_vals else 0.0,
        "SAC_avg_over_coords": float(np.mean(SAC_coords_avg)) if SAC_coords_avg else 0.0,
        "SAC_avg_over_bic": float(np.mean(SAC_bic_avg)) if SAC_bic_avg else 0.0,

        "LAP": LAP_ratio,          # per user's definition
        "LAP_abs2": LAP_abs2,      # the second-largest |LAT|
        "LAT": LAT,

        "DAP": DAP_ratio,          # per user's definition
        "DAP_val": DAP_val,        # the chosen DDT value (< 2^n)
        "DDT": DDT,

        "BCT2": BCT2, "FBCT2": FBCT2,
        "TO": TO, "MTO": MTO, "RTO": RTO,
        "MCC": MCC, "CCV": CCV, "SNR": SNR,

        "ANF": {"exprs": anf_exprs, "total_and": total_and, "total_xor": total_xor, "AD": ad},
        "BooleanFunctions": {"coords": coords, "bic": [bits for _, bits in bic]},
    }


# ===== Overlap-family kept faithful to your original math =====
def calculate_TO(sbox: List[int], n: int) -> float:
    """TO = n - (sum_{u!=0} | Σ_i A_fi(u) |) / ((2^n)^2 - 2^n)."""
    funcs = boolean_functions_from_sbox(sbox, n)
    Af = np.zeros((1 << n, n), dtype=np.int32)
    for i, bits in enumerate(funcs):
        for u in range(1 << n):
            acc = 0
            for x in range(1 << n):
                acc += 1 if (int(bits[x]) ^ int(bits[x ^ u])) == 0 else -1
            Af[u, i] = acc
    comb_abs = [abs(np.sum(Af[u, :])) for u in range(1 << n)]
    num = sum(comb_abs[1:])  # exclude u=0
    denom = (1 << (2 * n)) - (1 << n)
    return n - (num / denom)


def calculate_MTO(sbox: List[int], n: int) -> float:
    """MTO as in your original code."""
    funcs = boolean_functions_from_sbox(sbox, n)
    Af = np.zeros((n, n, 1 << n), dtype=np.int32)
    for i in range(n):
        for j in range(n):
            bi = funcs[i]
            bj = funcs[j]
            for u in range(1 << n):
                acc = 0
                for x in range(1 << n):
                    acc += 1 if (int(bi[x]) ^ int(bj[x ^ u])) == 0 else -1
                Af[i, j, u] = acc

    sums = []
    for u in range(1, 1 << n):
        for j in range(n):
            sums.append(int(np.sum(Af[:, j, u])))
    final_sum = sum(abs(v) for v in sums)
    denom = (1 << (2 * n)) - (1 << n)
    return n - (final_sum / denom)


def calculate_RTO(sbox: List[int], n: int) -> float:
    """RTO as in your original code."""
    funcs = boolean_functions_from_sbox(sbox, n)
    Af = np.zeros((n, n, 1 << n), dtype=np.int32)
    for i in range(n):
        for j in range(n):
            bi = funcs[i]
            bj = funcs[j]
            for u in range(1 << n):
                acc = 0
                for x in range(1 << n):
                    acc += 1 if (int(bi[x]) ^ int(bj[x ^ u])) == 0 else -1
                Af[i, j, u] = acc

    sums_u = []
    for u in range(1, 1 << n):
        sums_u.append(int(np.sum(Af[:, :, u])))
    final_sum = sum(abs(v) for v in sums_u)
    denom = (1 << (2 * n)) - (1 << n)
    return n - (final_sum / denom)


# =========================
# ====== PRINT HELPERS ====
# =========================
def print_boolean_functions(n: int, coords: List[str], bic_bits: List[str]) -> None:
    """Print Boolean functions in both BINARY and HEX for coords and BIC set."""
    print("================ BOOLEAN FUNCTIONS (BINARY & HEX) =========")
    print(f"Coordinate Boolean functions (n={n}, bit0=LSB):")
    for i, bits in enumerate(coords):
        print(f"  f{i}(x)  BINARY: {bits}")
        print(f"  f{i}(x)     HEX: {bitstring_to_hex(bits)}")
    print("\nBIC XOR-combination Boolean functions (f_i XOR f_j, i<j):")
    for k, bits in enumerate(bic_bits, 1):
        print(f"  g{k}(x)  BINARY: {bits}")
        print(f"  g{k}(x)     HEX: {bitstring_to_hex(bits)}")
    print("")


def print_per_function_reports(per_coord: List[Dict], per_bic: List[Dict]) -> None:
    """Print per-function NL and SAC (vector + average) for coords and BIC functions."""
    print("================ PER-FUNCTION NL & SAC (COORDS) ===========")
    for i, pc in enumerate(per_coord):
        sac_vec = ", ".join(f"{v:.4f}" for v in pc["SAC_vector"])
        print(f"f{i}: NL={pc['NL']:d} | SAC_vector=[{sac_vec}] | SAC_avg={pc['SAC_avg']:.4f}")
    print("\n================ PER-FUNCTION NL & SAC (BIC) ==============")
    for idx, pb in enumerate(per_bic, 1):
        i, j = pb["pair"]
        sac_vec = ", ".join(f"{v:.4f}" for v in pb["SAC_vector"])
        print(f"g{idx}=f{i}^f{j}: NL={pb['NL']:d} | SAC_vector=[{sac_vec}] | SAC_avg={pb['SAC_avg']:.4f}")
    print("")


def print_matrix_with_headers(M: List[List[int]], row_bits: int, col_bits: int, title: str) -> None:
    """Pretty ASCII matrix with hex headers (row index = alpha, col index = beta)."""
    rows, cols = len(M), (len(M[0]) if M else 0)
    print(f"================ {title} ================")
    hdr_w = max(1, (col_bits + 3) // 4)
    row_w = max(1, (row_bits + 3) // 4)
    header = [" " * (row_w + 2)] + [f"{c:0{hdr_w}X}" for c in range(cols)]
    print(" ".join(header))
    for r in range(rows):
        row_label = f"{r:0{row_w}X}:"
        values = " ".join(f"{M[r][c]:>4d}" for c in range(cols))
        print(f"{row_label} {values}")
    print("")




def parity(x: int) -> int:
    """Parity (xor of all bits). Works for integers of any bit width."""
    return x.bit_count() & 1

def fwht(seq: np.ndarray) -> np.ndarray:
    """
    In-place Fast Walsh–Hadamard Transform on a ±1 array.
    The size must be 2^n (n inferred automatically).
    """
    w = seq.astype(np.int16)             # 16-bit is sufficient for SIZE ≤ 2^8
    h = 1
    while h < len(w):
        for i in range(0, len(w), h << 1):
            j1, j2 = slice(i, i + h), slice(i + h, i + (h << 1))
            x, y = w[j1], w[j2]
            w[j1], w[j2] = x + y, x - y
        h <<= 1
    return w

def nonlinearity_bool(f_bits):
    """
    Nonlinearity of a single n-variable Boolean function.
    NL = 2^{n-1} - ½·max|Walsh|.
    """
    n = int(np.log2(len(f_bits)))
    seq = 1 - 2 * np.array(f_bits, dtype=np.int16)   # 0→1, 1→-1
    spectrum = fwht(seq)
    max_w = np.abs(spectrum).max()
    return (1 << (n - 1)) - (max_w // 2)

# ------------------------------------------------------------
#  Compute the nonlinearity of an S-box (any size 2^n × 2^m)
# ------------------------------------------------------------
def sbox_nonlinearity(sbox):
    SIZE = len(sbox)          # = 2^n
    n = int(np.log2(SIZE))
    if 1 << n != SIZE:
        raise ValueError("S-box length must be a power of 2 (2^n).")
    # Derive m from the maximum output value
    m = max(sbox).bit_length()
    HALF = 1 << (n - 1)

    # --- Boolean nonlinearity for each output bit ---
    nl_bits = []
    for bit in range(m):
        f = [(val >> bit) & 1 for val in sbox]
        nl_bits.append(nonlinearity_bool(f))
    nl_boolean_min = min(nl_bits)

    # --- Vectorial nonlinearity ---
    max_w = 0
    for a in range(1, SIZE):          # a ≠ 0
        for b in range(1, 1 << m):    # b ≠ 0
            s = 0
            for x in range(SIZE):
                ax = parity(a & x)
                bs = parity(b & sbox[x])
                s += 1 if (ax ^ bs) == 0 else -1
            if abs(s) > max_w:
                max_w = abs(s)
    nl_vector = HALF - (max_w // 2)

    return nl_bits, nl_boolean_min, nl_vector



import argparse, math
import numpy as np

# ---------------------------
# Ordered list of S-box names to analyze.
# Each name must be a variable defined in the module, e.g. SBOX4 = [...]
# ---------------------------
SBOX_NAMES = [
    "SBOX4", "SBOX6", "SBOX7", "SBOX8", "SBOX9", "SBOX10", "SBOX17", "SBOX20",
    "SBOX22", "SBOX25", "SBOX29", "SBOX32", "SBOX33", "SBOX36", "SBOX56",
    "SBOX69", "AES", "MDPISBOX", "MDPISBOX2"
]

# ---------------------------
# analyze_sbox(SBOX, name, idx, args)
#   - Performs all analysis and printing for one S-box.
#   - Reuse your existing helper functions: is_power_of_two, format_sbox_hex,
#     aggregate_metrics, print_boolean_functions, print_per_function_reports, sbox_nonlinearity, etc.
# ---------------------------
def analyze_sbox(SBOX, name, idx, args):
    # Validate the S-box
    if not SBOX:
        print(f"[{idx}/{len(SBOX_NAMES)}] SKIP {name}: S-box is empty.")
        return

    L = len(SBOX)
    if not is_power_of_two(L):
        print(f"[{idx}/{len(SBOX_NAMES)}] SKIP {name}: length {L} is not a power of two.")
        return
    n_auto = int(round(math.log2(L)))
    if (1 << n_auto) != L:
        print(f"[{idx}/{len(SBOX_NAMES)}] SKIP {name}: length is not exactly 2^n.")
        return
    n = args.n if args.n is not None else n_auto
    if (1 << n) != L:
        print(f"[{idx}/{len(SBOX_NAMES)}] SKIP {name}: inconsistent n (len={L} but n={n}).")
        return

    # Header
    print("\n" + "=" * 72)
    print(f"[{idx}/{len(SBOX_NAMES)}] VLSILAB — SBOX CRYPTANALYSIS  |  Name: {name}")
    print("=" * 72)
    print(f"n = {n}  (S-box size = {1<<n} entries)\n")
    print("S-box (hex):")
    print(format_sbox_hex(SBOX))
    print("")

    # Run existing aggregate and reporting pipeline
    res = aggregate_metrics(SBOX, n)

    print("============== CRYPTANALYSIS PARAMETERS ====================")
    print(f"0. Bijective: {'YES' if res['Bijective'] else 'NO'}")
    print(f"1. Fixed points: {res['FP']}")
    print(f"2. Opposite fixed points: {res['OFP']}\n")

    print("============== MAIN CRYPTOGRAPHIC CRITERIA =================")
    print(f"3.  Nonlinearity (avg over coords)       : {res['Sbox_NL_avg']:.6f}")
    print(f"4.  SAC average       (coords)           : {res['SAC_avg_over_coords']:.6f}")
    print(f"5.  BIC Nonlinearity  (avg over XORs)    : {res['BIC_NL_avg']:.6f}")
    print(f"6.  BIC SAC average   (XORs)             : {res['SAC_avg_over_bic']:.6f}")
    print(f"7.  LAP                                  : {res['LAP']:.6f}   | second |LAT| = {res['LAP_abs2']}")
    print(f"8.  DAP                                  : {res['DAP']:.6f}   | chosen DDT = {res['DAP_val']}\n")

    print("================ BOOMERANG ATTACK RESISTANCE ===============")
    print(f"9.1  BCT value : {res['BCT2']}")
    print(f"9.2  FBCT value: {res['FBCT2']}\n")

    print("============= SIDE-CHANNEL ATTACK RESISTANCE ==============")
    print(f"10. TO : {res['TO']:.6f}")
    print(f"11. MTO: {res['MTO']:.6f}")
    print(f"12. RTO: {res['RTO']:.6f}")
    print(f"13. MCC: {res['MCC']:.6f}")
    print(f"14. CCV: {res['CCV']:.6f}")
    print(f"15. SNR: {res['SNR']:.6f}\n")

    print("================ ANF (ALGEBRAIC NORMAL FORM) ===============")
    print(f"Algebraic Degree (max over coords): {res['ANF']['AD']}")
    print(f"Total AND gates across coords     : {res['ANF']['total_and']}")
    print(f"Total XOR gates across coords     : {res['ANF']['total_xor']}\n")

    # Boolean functions (binary + hex)
    print_boolean_functions(n, res["BooleanFunctions"]["coords"], res["BooleanFunctions"]["bic"])

    # Detailed per-function NL & SAC
    print_per_function_reports(res["PerCoord"], res["PerBIC"])

    # Optional LAT / DDT printing (uncomment if needed)
    # if not args.no_lat:
    #     print_matrix_with_headers(res["LAT"], row_bits=n, col_bits=n, title="LINEAR APPROXIMATION TABLE (LAT)")
    # if not args.no_ddt:
    #     print_matrix_with_headers(res["DDT"], row_bits=n, col_bits=n, title="DIFFERENTIAL DISTRIBUTION TABLE (DDT)")

    # Also print boolean and vectorial nonlinearities computed directly
    nl_bits, nl_boolean_min, nl_vector = sbox_nonlinearity(SBOX)
    print("Boolean function nonlinearities      :", nl_bits)
    print("Minimum Boolean nonlinearity         :", nl_boolean_min)
    print("Vectorial nonlinearity NL(S)         :", nl_vector)


# ---------------------------
# MAIN: run all S-boxes by default
# ---------------------------
def main():
    parser = argparse.ArgumentParser(
        description="VLSILAB — S-Box Cryptanalysis"
    )
    parser.add_argument("--n", type=int, default=None,
                        help="Override n (bits). If omitted, inferred from len(SBOX).")
    parser.add_argument("--no-lat", action="store_true", help="Do not print LAT to console.")
    parser.add_argument("--no-ddt", action="store_true", help="Do not print DDT to console.")
    parser.add_argument("--name", type=str, default=None,
                        help="Analyze a single S-box by name (e.g., SBOX4). If omitted, runs all names in SBOX_NAMES.")
    parser.add_argument("--single-index", type=int, default=None,
                        help="Analyze a single S-box by 1-based index in SBOX_NAMES (overrides --name).")
    args = parser.parse_args()

    # If user requested a single run by index, run that only
    if args.single_index is not None:
        idx = args.single_index
        if not (1 <= idx <= len(SBOX_NAMES)):
            raise ValueError(f"--single-index must be between 1 and {len(SBOX_NAMES)}")
        name = SBOX_NAMES[idx - 1]
        if name not in globals():
            raise ValueError(f"S-box '{name}' is not defined in this module.")
        analyze_sbox(globals()[name], name, idx, args)
        return

    # If user requested a single run by name, run that only
    if args.name:
        name = args.name
        if name not in SBOX_NAMES:
            print(f"Warning: '{name}' is not in the standard list; attempting to find variable by that name.")
        if name not in globals():
            raise ValueError(f"S-box '{name}' is not defined in this module.")
        analyze_sbox(globals()[name], name, 1, args)
        return

    # Default: run all names in order
    for idx, name in enumerate(SBOX_NAMES, start=1):
        if name not in globals():
            print(f"[{idx}/{len(SBOX_NAMES)}] SKIP {name}: variable not defined in module.")
            continue
        sbox = globals()[name]
        analyze_sbox(sbox, name, idx, args)


# Optionally set a default SBOX variable for single-run legacy behavior (not required)
# SBOX = MDPISBOX2

if __name__ == "__main__":
    main()
